module dma_top(
    input  wire        clk,
    input  wire        rst,
    input  wire [7:0]  data_in,
    input  wire [2:0]  instr,
    input  wire        WCI,   // external terminal-count acknowledge
    input  wire        ACI,   // address carry inhibit
    output wire        done
);

    wire [1:0] word_inc;
    wire       addr_inc;

    wire load_ctrl;
    wire load_addr;
    wire load_word;
    wire en_a;
    wire en_w;

    // Instruction decoder
    instr_decoder u_dec (
        .clk(clk),
        .rst(rst),
        .instr(instr),
        .load_ctrl(load_ctrl),
        .load_addr(load_addr),
        .load_word(load_word),
        .en_a(en_a),
        .en_w(en_w)
    );

    // Control register
    control u_ctrl (
        .clk(clk),
        .rst(rst),
        .load_ctrl(load_ctrl),
        .data_in(data_in),
        .word_inc(word_inc),
        .addr_inc(addr_inc)
    );

    // Word counter
    word_counter u_word (
        .clk(clk),
        .rst(rst),
        .en_w(en_w),
        .load_w(load_word),
        .data_in(data_in),
        .word_inc(word_inc),
        .WCI(WCI)
    );

    // Address counter
    address_counter u_addr (
        .clk(clk),
        .rst(rst),
        .en_a(en_a),
        .load_a(load_addr),
        .data_in(data_in),
        .addr_inc(addr_inc),
        .ACI(ACI)
    );

    // Done logic
    done_logic u_done (
        .clk(clk),
        .rst(rst),
        .en_w(en_w),
        .WCI(WCI),
        .done(done)
    );

endmodule

module instr_decoder(
    input  wire clk,
    input  wire rst,
    input  wire [2:0] instr,
    output reg  load_ctrl,
    output reg  load_addr,
    output reg  load_word,
    output reg  en_a,
    output reg  en_w
);

always @(posedge clk) begin
    if (rst) begin
        load_ctrl <= 0;
        load_addr <= 0;
        load_word <= 0;
        en_a      <= 0;
        en_w      <= 0;
    end else begin
        load_ctrl <= 0;
        load_addr <= 0;
        load_word <= 0;
        en_a      <= 0;
        en_w      <= 0;

        case (instr)
            3'b000: load_ctrl <= 1; // load control register
            3'b101: load_addr <= 1; // load address register
            3'b110: load_word <= 1; // load word count register
            3'b111: begin           // start DMA
                en_a <= 1;
                en_w <= 1;
            end
        endcase
    end
end
endmodule

module control(
    input  wire       clk,
    input  wire       rst,
    input  wire       load_ctrl,
    input  wire [7:0] data_in,
    output wire [1:0] word_inc,
    output wire       addr_inc
);

reg [2:0] control_reg;

always @(posedge clk) begin
    if (rst)
        control_reg <= 3'b000;
    else if (load_ctrl)
        control_reg <= data_in[2:0];
end

assign word_inc = control_reg[1:0];
assign addr_inc = control_reg[2];

endmodule


module word_counter(
    input  wire       clk,
    input  wire       rst,
    input  wire       en_w,
    input  wire       load_w,
    input  wire [7:0] data_in,
    input  wire [1:0] word_inc,
    output wire       WCI
);

reg [7:0] wordc_reg;   // programmed word count (CPU-visible)
reg [7:0] word_count;  // current word count

always @(posedge clk) begin
    if (rst) begin
        wordc_reg  <= 8'd0;
        word_count <= 8'd0;
    end else if (load_w) begin
        wordc_reg  <= data_in;
        word_count <= data_in;
    end else if (en_w && !WCI) begin
        case (word_inc)
            2'b00: word_count <= word_count - 1; // normal DMA decrement
            2'b01: word_count <= word_count + 1; // increment mode
            2'b10: word_count <= word_count;     // hold
            2'b11: word_count <= word_count + 1; // alternate mode
        endcase
    end
end

assign WCI = (word_count == 0);

endmodule

module address_counter(
    input  wire       clk,
    input  wire       rst,
    input  wire       en_a,
    input  wire       load_a,
    input  wire [7:0] data_in,
    input  wire       addr_inc,
    input  wire       ACI
);

reg [7:0] addr_count;

always @(posedge clk) begin
    if (rst)
        addr_count <= 8'd0;
    else if (load_a)
        addr_count <= data_in;
    else if (en_a && !ACI) begin
        if (addr_inc)
            addr_count <= addr_count + 1;
        else
            addr_count <= addr_count - 1;
    end
end

endmodule


module done_logic(
    input  wire clk,
    input  wire rst,
    input  wire en_w,
    input  wire WCI,
    output reg  done
);

always @(posedge clk) begin
    if (rst)
        done <= 0;
    else if (!en_w)
        done <= 0;
    else if (WCI)
        done <= 1;
end

endmodule